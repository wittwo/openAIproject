import openai
import json
from typing import Any, List, Dict
import logging
from database_utils import query_database
from tools import FeedExtract
from source import ExtractDataModelSchemas,getpbits

#Some functions to test
def get_database_details(table):
    """Get details of spacific database"""
    table_info = {}
    if table.lower()=="client":
        { #generated by AI
  "table": "ClientData",
  "columns": """customerTypeID,offerID2,customerOfferID3,customerOfferID4,customerOfferID5,categoryIDOffer,
            customerOfferID,customerStatusID,commercialNetworkID,franchiseNetworkID,entityTypeID,clientGUID,approvalStatus,customerLocation,customerType,customerSummary,groupCategory1,
            groupCategory2,groupCategory3,clientFullName,clientShortName,clientState,clientIdentifier,clientIdentifierAlt,clientComments,commercialNetworkName,communeName,regionName,extraField1,
            extraField2,extraField3,extraField4,extraField5,customerEmail,franchiseNetworkName,
            entityLegalType,localEmail,contactNumber,postCode,registryAcronym,addressLine,TIN,regionProvince,recordCreationDate,isCustomer,isDistributor,isNotApproved,isPaymentPending""",
  "column_description": """
                Approval status for client request.
ID for client's type (e.g., individual, corporate).
ID for Offer 2.
ID for Offer 3.
ID for Offer 4.
ID for Offer 5.
Category ID for Offer.
Client's Offer ID.
Client's status ID.
ID for current commercial network.
ID for franchise network.
Type of legal entity ID.
Unique GUID for the client.
Status of client's approval.
Location of the client.
Type of client (e.g., individual, corporate).
Brief summary of the client.
Group category 1 for client.
Group category 2 for client.
Group category 3 for client.
Full name of the client.
Shortened name of the client.
State of the client.
Primary identifier for the client.
Alternate identifier for the client.
Comments or remarks about the client.
Name of the commercial network.
Commune of the client's address.
Region or province of the client's address.
Extra field for additional data.
Extra field for additional data.
Extra field for additional data.
Extra field for additional data.
Extra field for additional data.
Email address of the client.
Name of the franchise network.
Type of legal entity.
Local operational email for the client.
Contact number of the client.
Postal code.
Acronym for the National Economy Registry.
Address line of the client.
Tax Identification Number of the client.
Region or province of the client's address.
Date when the record was created.
Indicates if the entity is a customer.
Indicates if the entity is a distributor.
Indicates if the entity is not approved.
Indicates if payment is pending for the client.
            """
}
    else:
        return "Couldn't find information"
    return json.dumps(table_info)

def get_current_weather(location, unit="fahrenheit"):
    """Get the current weather in a given location"""
    weather_info = {
        "location": location,
        "temperature": "72",
        "unit": unit,
        "forecast": ["sunny", "windy"],
    }
    return json.dumps(weather_info)

functions = [
    {
            "name": "get_database_details",
            "description": "Get specific column names of one table from company system database, if you know the table name",
            "parameters": {
                "type": "object",
                "properties": {
                    "table": {
                        "type": "string",
                        "description": "Table name",
                    }
                },
                "required": ["table"],
            },
        },
        {
            "name": "get_current_weather",
            "description": "Get the current weather in a given location",
            "parameters": {
                "type": "object",
                "properties": {
                    "location": {
                        "type": "string",
                        "description": "The city and state, e.g. San Francisco, CA",
                    },
                    "unit": {"type": "string", "enum": ["celsius", "fahrenheit"]},
                },
                "required": ["location"],
            },
        },
         {
            "name": "query_database",
            "description": "Get general information about company system, Sagra and its employees, databases, tables, descriptions. If there is a question about a table with unspecified name, use this function as well.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "Query in natural language to generate additional info about copmany system",
                    }
                },
                "required": ["query"],
            },
        },
        {
            "name": "look_for_feeds",
            "description": "Find feed/table names in local power bi, .pbix, report files",
            "parameters": {
                "type": "object",
                "properties": {
                    "value": {
                        "type": "integer",
                        "description": "If you want to use this function set the description to 1",
                    }
                },
                "required": ["value"],
            },
        }
        ]

def apply_prompt_template(question: str) -> str:
    """
        A helper function that applies additional template on user's question.
        Prompt engineering could be done here to improve the result. Here I will just use a minimal example.
    """
    prompt = f"""
        Zachowuj się jak czat. Jeśli potrzeba, możesz korzystać z powyższych danych. Odpowiedz na pytanie: {question}. Odpowiadaj na temat. Nie zawsze musisz korzystać z dodatkowej wiedzy.
        Jeśli w podanych danych występują nazwy kolumn lub tabel w danym języku, to ich nie tłumacz. Podawaj tylko oryginalne dane. 
    """
    return prompt

def call_chatgpt_api(messages,user_question: str) -> Dict[str, Any]:
    """
    Call chatgpt api with user's question and retrieved chunks.
    """
    # Send a request to the GPT-3 API
    #messagesChunk = list(
    #    map(lambda chunk: {
    # #       "role": "user",
    #        "content": chunk
    #    }, chunks))

    #messages.extend(messagesChunk)

    question = apply_prompt_template(user_question)
    messages.append({"role": "user", "content": question})
    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo-0613",
        messages=messages,
        functions=functions,
        function_call="auto",  # auto is default, but we'll be explicit
        max_tokens=1024,
        temperature=0.7,
    )
    
    
    return messages,response

def check_function_call(messages,response):
    #print(response)
    response_message=response["choices"][0]["message"]
    if response_message.get("function_call"):
        # Step 3: call the function
        # Note: the JSON response may not always be valid; be sure to handle errors
        available_functions = {
            "get_database_details": get_database_details,
            "get_current_weather": get_current_weather,
            "query_database": query_database,
            "look_for_feeds": FeedExtract
        }  # only one function in this example, but you can have multiple
        function_name = response_message["function_call"]["name"]
        print("Posilę się funkcją ",function_name)
        fuction_to_call = available_functions[function_name]
        function_args = json.loads(response_message["function_call"]["arguments"])
        if function_name=="get_current_weather":
            function_response = fuction_to_call(
                location=function_args.get("location"),
                unit=function_args.get("unit"),
            )
        elif function_name=="get_database_details":
            function_response = fuction_to_call(
                table=function_args.get("table")
            )
        elif function_name=="query_database":
            function_response = fuction_to_call(
                query_prompt=function_args.get("query")
            )
            function_response=str(function_response)
        elif function_name=='look_for_feeds':
            PATH_TO_FILES = "\Python"
            files_list,files_names,files_MAX31,files_count = getpbits(PATH_TO_FILES)
            with open("data.json", "r", encoding="utf-8") as file:
                # Load JSON data
                json_data = json.load(file)
                json_data = json.dumps(json_data, indent=2)
            result=FeedExtract(json_data,files_names)
            function_response='Feeds extracted to Feedy.json file'
        # Step 4: send the info on the function call and function response to GPT
        messages.append(response_message)  # extend conversation with assistant's reply
        messages.append(
            {
                "role": "function",
                "name": function_name,
                "content": function_response,
            }
        )  # extend conversation with function response
        second_response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo-0613",
            messages=messages,
        )  # get a new response from GPT where it can see the function response
        
        return second_response
    else:
        second_response = response
        #print("Sc",second_response)
        return second_response

def ask(messages, user_question: str) -> Dict[str, Any]:
    """
    Handle user's questions.
    """
    # Get chunks from database.
    #chunks_response = query_database(user_question)
    #chunks = []
    #for result in chunks_response["results"]:
    #    for inner_result in result["results"]:
    #        chunks.append(inner_result["text"])
    
    logging.info("User's questions: %s", user_question)
    #logging.info("Retrieved chunks: %s", chunks)
    
    messages,response = call_chatgpt_api(messages,user_question)
    final_response = check_function_call(messages,response)
    
    logging.info("Response: %s", response)
    assistant_message = final_response["choices"][0]["message"]
    content = assistant_message.get("content")
    if content:
        messages.append({"role": "assistant", "content": content})
    #print(messages,assistant_message)

    return messages, assistant_message
